library ieee;
use ieee.std_logic_1164.all;
use ieee.math_real.all;

entity FPGA_FIFO_UART is
  port (
    -- Main Clock (50 MHz)
    MAX10_CLK1_50         : in std_logic;
 
    -- UART Data
	 GPIO 			: inout std_logic_vector(35 downto 0);
	 
	 --Reset Button
	 SW : in std_logic_vector(9 downto 0);
     
    -- Segment1 is upper digit, Segment2 is lower digit
	 HEX0	:OUT STD_LOGIC_VECTOR(6 DOWNTO 0);	--Lower num
	 HEX1	:OUT STD_LOGIC_VECTOR(6 DOWNTO 0);	--Higher num
	 HEX2	:OUT STD_LOGIC_VECTOR(6 DOWNTO 0);	--Lower num
	 HEX3	:OUT STD_LOGIC_VECTOR(6 DOWNTO 0);	--Higher num
	 LEDR	:OUT STD_LOGIC_VECTOR(9 DOWNTO 0)
		
    );
end entity FPGA_FIFO_UART;
 
architecture RTL of FPGA_FIFO_UART is


	component UART_RX is
	  port (
		 i_Clk       : in  std_logic;
		 i_RX_Serial : in  std_logic;
		 o_RX_DV     : out std_logic;
		 o_RX_Byte   : out std_logic_vector(7 downto 0)
		 );
	end component;
	component UART_TX is
	  port (
		 i_Clk       : in  std_logic;
		 i_TX_DV     : in  std_logic;
		 i_TX_Byte   : in  std_logic_vector(7 downto 0);
		 o_TX_Active : out std_logic;
		 o_TX_Serial : out std_logic;
		 o_TX_Done   : out std_logic
		 );
	end component;
	component ss_decoder is
	port(
		ssd_in :in std_logic_vector(3 downto 0);
		ssd_out:out std_logic_vector(6 downto 0)
		);
	END component;
	component FIFO_NandLand is
	  generic (
		 g_WIDTH : natural;
		 g_DEPTH : integer
		 );
	  port (
		 i_rst_sync : in std_logic;
		 i_clk      : in std_logic;
	 
		 -- FIFO Write Interface
		 i_wr_en   : in  std_logic;
		 i_wr_data : in  std_logic_vector(g_WIDTH-1 downto 0);
		 o_full    : out std_logic;
	 
		 -- FIFO Read Interface
		 i_rd_en   : in  std_logic;
		 o_rd_data : out std_logic_vector(g_WIDTH-1 downto 0);
		 o_empty   : out std_logic
		 );
	end component;
	component clk_gen is
		generic(
					GENBITS : integer;     -- Needs to be set correctly
					high_rate_cnt : integer;     -- Needs to be set correctly
					low_rate_cnt  : integer     -- Needs to be set correctly
			 );
		port(
				rst_L 	:in std_logic;
				clk_in	:in std_logic;
				rate		:in std_logic;
				clk		:out std_logic
			);
	end component;
  
  constant GENBITS: integer := integer(ceil(log2(real(integer(434)))));
  -- Signal for UART
  signal w_RX_DV     : std_logic;
  signal w_RX_Byte   : std_logic_vector(7 downto 0);
  signal w_TX_Active : std_logic;
  signal w_TX_Serial : std_logic;
  
  -- Signal for FIFO
  constant	 g_WIDTH : natural := 8;
  constant	 g_DEPTH : integer := 3;
  Signal reset, wr_en, rd_en	:std_logic;
  Signal fifo_f, fifo_e			:std_logic;
  signal wr_data, rd_data		:std_logic_vector(g_WIDTH-1 downto 0);
  
  -- Signal for FSM
  signal Reset_f, tx_dv, rx_dv, tx_done, clk_g		:std_logic;
  signal CTS_C, RTS_C, CTS_X, RTS_X		:std_logic;
  type state_type is (rx, tx, int, tx_ready, idle);
  SIGNAL PS, NS :state_type;
  
 
begin
 
  UART_RX_Inst :  UART_RX
    port map (
      MAX10_CLK1_50,
      GPIO(0),
      rx_dv,
      wr_data);
 
 
  -- Creates a simple loopback to test TX and RX
  UART_TX_Inst :  UART_TX
    port map (
      MAX10_CLK1_50,
      tx_dv,
      rd_data,
      w_TX_Active,
      w_TX_Serial,
      tx_done
      );
		
	fifo_fpga: FIFO_NandLand 	Generic map(g_WIDTH, g_DEPTH)
										port map(Reset_f, MAX10_CLK1_50,
													wr_en, wr_data, fifo_f,
													rd_en, rd_data, fifo_e);
		
  -- Drive UART line high when transmitter is not active
  GPIO(1) <= w_TX_Serial when w_TX_Active = '1' else '1';
   
  -- Binary to 7-Segment Converter for Lower Digit 
  rx_lower: ss_decoder port map(wr_data(3 downto 0), HEX0(6 downto 0));
  -- Binary to 7-Segment Converter for Upper Digit 
  rx_upper: ss_decoder port map(wr_data(7 downto 4), HEX1(6 downto 0));
  
  -- Binary to 7-Segment Converter for Lower Digit 
  tx_lower: ss_decoder port map(rd_data(3 downto 0), HEX2(6 downto 0));
  -- Binary to 7-Segment Converter for Upper Digit 
  tx_upper: ss_decoder port map(rd_data(7 downto 4), HEX3(6 downto 0));

  clkgen: clk_gen 	Generic map (GENBITS, integer(1), integer(434))
						port map (Reset_f, MAX10_CLK1_50, '0', clk_g);
   
	
	RTS_X <= SW(1);
	RTS_C <= SW(2);
	
	syn: process(MAX10_CLK1_50)
	begin 
		if(SW(0)='1')then 
			Reset_f <= '1';
			PS <= int;
		else
			Reset_f <= '0';
			if(MAX10_CLK1_50'event and MAX10_CLK1_50='1')then
				PS <= NS;
			else
				PS <= PS;
			end if;
		end if;
	end process;
  
  Fun: process(PS)
  begin 
		Case PS is
			when int => 
				--wr_data <= (others => '0');
				--rd_data <= (others => '0');
				wr_en <= '0';
				rd_en <= '0';
				tx_dv <= '0';
				NS <= idle;
			when idle => 
				LEDR(2 downto 0) <= "001";
				wr_en <= '0';
				rd_en <= '0';
				tx_dv <= '0';
				if RTS_X = '1' then
					NS <= rx;
				elsif RTS_C = '1' then
					NS <= tx_ready;
				else NS <= idle;
				end if;
			when rx =>
				LEDR(2 downto 0) <= "010";
				tx_dv <= '0';
				--if fifo_f = '1' then NS <= tx;
				if fifo_f = '0' then 
					if rx_dv='1' then
						wr_en <= '1';
						rd_en <= '0';
						--LEDR(6 downto 5) <= "01";
					end if;
				end if;
				NS <= idle;
			when tx_ready =>
				if w_TX_Active='0' and RTS_C = '1' then
					if fifo_e = '0' then 
						wr_en <= '0';
						rd_en <= '1';				
					end if;
				else
					wr_en <= '0';
					rd_en <= '0';	
				end if;
				NS <= tx;
			when tx =>
				--LEDR(2 downto 0) <= "100";
				if RTS_C = '1' and fifo_e = '0' then
					if (w_TX_Active='1') then
						--tx_dv <= '0';
						NS <= tx;
					elsif (rd_en = '1') and (wr_en = '0') then
						tx_dv <= '1';
						rd_en <= '0';
						wr_en <= '0';
						NS <= tx;
					end if;
				else 
					rd_en <= '0';
					wr_en <= '0';
					tx_dv <= '0';
					NS <= idle;
				end if;
			when others => NS <= int;
		end case;  
  end process;
  
  LEDR(9) <= fifo_f;
  LEDR(8) <= fifo_e;
  --LEDR(7) <= rx_dv;
  --LEDR(6) <= tx_dv;
  LEDR(7 downto 5) <= "001" when wr_en = '0' and rd_en = '0' else
							 "010" when wr_en = '1' and rd_en = '0' else
							 "100" when wr_en = '0' and rd_en = '1' else
							 "000";
 
   
end architecture RTL;